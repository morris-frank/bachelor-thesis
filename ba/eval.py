from ba.selectivesearch import selective_search
import ba.utils
import numpy as np
import skimage.transform
from scipy.misc import imread
from tqdm import tqdm
import yaml


def evalYAML(predf, gtf):
    preds = ba.utils.loadYAML(predf)
    gts = ba.utils.loadYAML(gtf)
    outputf = '.'.join(predf.split('.')[:-2] + ['evals', 'yaml'])
    results = {}
    print('Evaluating {}'.format(predf))
    for idx, rect in tqdm(preds.items()):
        im = imread('data/datasets/voc2010/JPEGImages/{}.jpg'.format(idx))
        gtslice = gts[idx]
        gtrect = (gtslice[0].start, gtslice[1].start,
                  gtslice[0].stop, gtslice[1].stop)
        iOU = intersectOverUnion(rect, gtrect)
        l2dist = rectDistance(rect, gtrect)
        diagonal = np.linalg.norm(im.shape[:-1])
        disterr = float(l2dist / diagonal)
        scalingerr = float(np.linalg.norm(
            [(rect[2] - rect[0]) / (gtrect[2] - gtrect[0]),
             (rect[3] - rect[1]) / (gtrect[3] - gtrect[1])]))
        results[idx] = {'iOU': iOU, 'disterr': disterr,
                        'scalingerr': scalingerr}

    meanIOU = float(np.mean([i['iOU'] for i in results.values()]))
    meanDistErr = float(np.mean([i['disterr'] for i in results.values()]))
    meanScalErr = float(np.mean([i['scalingerr'] for i in results.values()]))
    results['mean_iOU'] = meanIOU
    results['mean_disterr'] = meanDistErr
    results['mean_scalingerr'] = meanScalErr
    with open(outputf, 'w') as f:
        yaml.dump(results, f)


def rectDistance(a, b):
    '''Calculates the distance between the centers of two rectangles.

    Args:
        a (tuple): (xmin ymin xmax ymax)
        b (tuple): (xmin ymin xmax ymax)

    Returns the iOU
    '''
    aCenter = np.array([(a[0] + a[2]) / 2.0, (a[1] + a[3]) / 2.0])
    bCenter = np.array([(b[0] + b[2]) / 2.0, (b[1] + b[3]) / 2.0])
    return np.linalg.norm(aCenter - bCenter)


def intersectOverUnion(a, b):
    '''Calculates the intersect over Union of two rectangles.

    Args:
        a (tuple): (xmin ymin xmax ymax)
        b (tuple): (xmin ymin xmax ymax)

    Returns the iOU
    '''
    area = intersectArea(a, b)
    if area == 0:
        return area
    aArea = (a[2] - a[0]) * (a[3] - a[1])
    bArea = (b[2] - b[0]) * (b[3] - b[1])
    iOU = area / float(aArea + bArea - area)
    return iOU


def intersectArea(a, b):
    '''Calculates the area of the intersecting area of two rectangles.

    Args:
        a (tuple): (xmin ymin xmax ymax)
        b (tuple): (xmin ymin xmax ymax)

    Returns the area
    '''
    dx = min(a[2], b[2]) - max(a[0], b[0])
    dy = min(a[3], b[3]) - max(a[1], b[1])
    if dx >= 0 and dy >= 0:
        return dx * dy
    else:
        return 0.0


def scoreToRegion(heatmap, image):
    '''Reudces a heatmap to a bounding box by searching through regions of the
    image generated by an selective search.

    Args:
        heatmap (ndarray): The map of normalized scores
        image (ndarray): The image

    Returns:
        The maximum bounding box (x_start, y_start, x_end, y_end)
    '''
    labels, regions = selective_search(image, scale=500, sigma=0.9, min_size=200)
    starts = []
    ends = []
    for region in regions:
        y2, x2, y1, x1 = region['rect']
        if x2 < x1:
            x2,x1 = x1,x2
        if y2 < y1:
            y2,y1 = y1,y2
        starts.append((x1, y1))
        ends.append((x2, y2))
    integral_scores = skimage.transform.integral_image(heatmap)

    bbscores = skimage.transform.integrate(integral_scores, starts, ends)
    bbidx = bbscores.argmax()
    x, y = starts[bbidx]
    x2, y2 = ends[bbidx]
    regmax = (x, y, x2, y2)

    return regmax
